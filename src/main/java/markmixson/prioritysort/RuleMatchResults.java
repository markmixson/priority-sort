package markmixson.prioritysort;

import java.nio.ByteBuffer;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.BitSet;
import java.util.Objects;

import com.google.common.primitives.Bytes;

/**
 * Record representing rule match results.
 */
record RuleMatchResults(BitSet matched, ZonedDateTime date, Long id) {

    /**
     * Null-hostile constructor.
     * 
     * @param matched rule matches in the form a {@link BitSet}.  Bitset must be generated by the {@link BitSetGenerator}.
     * @param date the item date used for prioritizing items with equivalent rules.
     * @param id the item id.
     */
    public RuleMatchResults {
        Objects.requireNonNull(matched, "must have a set of match/non-matched rules!");
        Objects.requireNonNull(date, "cannot have an empty claim date!");
        Objects.requireNonNull(id, "cannot have an empty id!");
    }

    /**
     * Converts the record into a big-endian byte format.
     * 
     * @return a {@link byte[]} representing the {@link RuleMatchResults}.
     */
    public byte[] toByteArray() {
        final var buffer = ByteBuffer.allocate(Long.BYTES * 2);
        buffer.putLong(date().toEpochSecond());
        buffer.putLong(id());
        return Bytes.concat(matched().toByteArray(), buffer.array());
    }

    /**
     * Given a {@link byte[]}, get a {@link RuleMatchResults} back.
     * 
     * @param bytes the bytes to convert.
     * @return the {@link RuleMatchResults}.
     */
    public static RuleMatchResults getRuleMatchResults(final byte[] bytes) {
        Objects.requireNonNull(bytes, "byte array cannot be null!");
        if (bytes.length == 0) {
            throw new IllegalArgumentException("byte array cannot be empty!");
        }
        return getRuleMatchResults(ByteBuffer.wrap(bytes));
    }

    private static RuleMatchResults getRuleMatchResults(final ByteBuffer input) {
        final var matchedSize = input.array().length - (Long.BYTES * 2);
        final var matchedSlice = input.slice(0, matchedSize);
        final var dateSlice = input.slice(matchedSize, Long.BYTES);
        final var idSlice = input.slice(matchedSize + Long.BYTES, Long.BYTES);
        return new RuleMatchResults(
                BitSet.valueOf(matchedSlice),
                ZonedDateTime.ofInstant(
                        Instant.ofEpochSecond(dateSlice.getLong()), ZoneId.of("UTC")),
                idSlice.getLong());
    }
}
